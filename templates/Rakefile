require 'rake'

#
# VirtualBox Tasks
#

VMNAME  = ENV['LINE_COOK_VM_NAME'] || 'vbox'
VUSER   = ENV['LINE_COOK_VM_USER'] || 'vbox'
KEYPATH = File.expand_path('../vbox/ssh/id_rsa', __FILE__)

namespace :vbox do
  desc "start the #{VMNAME} vm"
  task :start do
    type = ENV['TYPE'] || 'headless'
    unless `VBoxManage -q list runningvms`.include?(VMNAME)
      sh "VBoxManage -q startvm #{VMNAME} --type #{type}"
    end
  end

  desc "stop the #{VMNAME} vm (poweroff)"
  task :stop do
    if `VBoxManage -q list runningvms`.include?(VMNAME)
      sh "VBoxManage -q controlvm #{VMNAME} poweroff"
    end
  end

  desc "reset the vm to SNAPSHOT (default BASE)"
  task :reset do
    type = ENV['TYPE'] || 'headless'
    name = ENV['SNAPSHOT'] || 'BASE'

    if `VBoxManage -q list runningvms`.include?(VMNAME)
      sh "VBoxManage -q controlvm #{VMNAME} poweroff"
    end

    sh "VBoxManage -q snapshot #{VMNAME} restore #{name.upcase}"
    sh "VBoxManage -q startvm #{VMNAME} --type #{type}"
  end

  desc "take the snapshop specified by SNAPSHOT"
  task :snapshot do
    name = ENV['SNAPSHOT']
    raise "no snapshot name specified in ENV['SNAPSHOT']" unless name

    `VBoxManage -q snapshot #{VMNAME} delete #{name.upcase} > /dev/null`
    sh "VBoxManage -q snapshot #{VMNAME} take #{name.upcase}"
  end

  desc "print the state of the #{VMNAME} vm"
  task :state do
    if `VBoxManage -q list runningvms`.include?(VMNAME)
      puts "running"
    else
      puts "stopped"
    end
  end

  desc "ssh to the #{VMNAME} vm (executes COMMAND)"
  task :ssh do
    # To prevent ssh errors, protect the private key
    FileUtils.chmod(0600, KEYPATH)

    # Patterned after vagrant/ssh.rb (circa 0.6.6)
    platform = RUBY_PLATFORM.to_s.downcase
    ssh = "ssh -p 2222 -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o IdentitiesOnly=yes -i #{KEYPATH} #{VUSER}@localhost #{ENV['COMMAND']}"

    # Some hackery going on here. On Mac OS X Leopard (10.5), exec fails
    # (GH-51). As a workaround, we fork and wait. On all other platforms, we
    # simply exec.

    pid = nil
    pid = fork if platform.include?("darwin9") || platform.include?("darwin8")
    Kernel.exec(ssh)  if pid.nil?
    Process.wait(pid) if pid
  end
end

#
# Linecook Setup
#

require 'linecook'
pwd = File.expand_path('..', __FILE__)
cookbook = Linecook::Cookbook.init(pwd)

#
# Linecook Helper Tasks
# (compiles helper modules from helper definitions, as needed)

cookbook.each_helper do |sources, target, const_name|
  file target => sources do
    puts "  helper: #{const_name}" unless Rake.application.options.silent
    helper = Linecook::Helper.new(const_name, sources)
    helper.build_to(target, :force => true)
  end
  
  task :helpers => target
end

desc "generate helpers"
task :helpers

#
# Linecook Script Tasks
# (compiles scripts, as directed)

cookbook.each_script do |source, target, name|
  task target => [:helpers, source] do
    puts "  script: #{name}" unless Rake.application.options.silent
    script = Linecook::Script.new(cookbook.manifest, YAML.load_file(source))
    script.build_to(target, :force => true)
  end
  
  namespace :scripts do
    desc "generate script: #{name}"
    task name => target
  end
  
  task :scripts => "scripts:#{name}"
end

desc "generate scripts"
task :scripts => :bundle

#
# Dependency tasks
#

desc 'Bundle dependencies'
task :bundle do
  output = `bundle check 2>&1`
  
  unless $?.to_i == 0
    puts output
    sh "bundle install 2>&1"
    puts
  end
end

#
# Gem tasks
#

require 'rake/rdoctask'
require 'rake/gempackagetask'

def gemspec
  @gemspec ||= eval(File.read('<%= project_name %>.gemspec'), TOPLEVEL_BINDING)
end

desc 'Prints the gemspec manifest.'
task :print_manifest do
  files = gemspec.files.inject({}) do |files, file|
    files[File.expand_path(file)] = [File.exists?(file), file]
    files
  end
  
  cookbook_files = Dir.glob('{attributes,files,lib,recipes,templates}/**/*')
  cookbook_file  = Dir.glob('{Cc}ookbook')
  
  (cookbook_files + cookbook_file).each do |file|
    path = File.expand_path(file)
    files[path] = ['', file] unless files.has_key?(path)
  end
  
  # sort and output the results
  files.values.sort_by {|exists, file| file }.each do |entry| 
    puts '%-5s %s' % entry
  end
end

#
# Documentation tasks
#

desc 'Generate documentation.'
Rake::RDocTask.new(:rdoc) do |rdoc|
  spec = gemspec
  
  rdoc.rdoc_dir = 'rdoc'
  rdoc.options.concat(spec.rdoc_options)
  rdoc.rdoc_files.include(spec.extra_rdoc_files)
  
  files = spec.files.select {|file| file =~ /^lib.*\.rb$/}
  rdoc.rdoc_files.include( files )
end
