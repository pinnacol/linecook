require 'line_cook/templater'

module LineCook
  class Helper < Templater
    class << self
      def each_helper(dir, &block)
        sources, dirs = Dir.glob("#{dir}/*").partition {|path| File.file?(path) }
        
        # recursively iterate for helpers
        dirs.each {|path| each_helper(path, &block) }
        
        # generate and yield current helper
        yield dir, new(sources)
      end
    end
    
    attr_reader :sources
    
    def initialize(sources)
      @sources = sources
      @section_paths, @definition_paths = sources.partition {|path| File.basename(path)[0] == ?_ }
      super()
    end
    
    def build(const_name)
      eval MODULE_TEMPLATE, binding, __FILE__, MODULE_TEMPLATE_LINE
      target.string
    end
    
    def sections
      @sections ||= begin
        sections = {}
        
        @section_paths.each do |path|
          key = File.basename(path)[1..-1]
          key.chomp! File.extname(path)
          sections[key.to_sym] = File.read(path)
        end
        
        sections
      end
    end
    
    def definitions
      @definitions ||= @definition_paths.collect do |path|
        extname = File.extname(path)
        name    = File.basename(path).chomp(extname)
        desc, signature, body = parse File.read(path)
        
        case extname
        when '.erb' then eval ERB_TEMPLATE, binding, __FILE__, ERB_TEMPLATE_LINE
        when '.rb'  then eval RB_TEMPLATE,  binding, __FILE__, RB_TEMPLATE_LINE
        else raise "invalid definition: #{path}"
        end
      end
    end
    
    private
    
    def parse(str)
      head, body = str.split(/^--.*\n/, 2)
      head, body = '', head if body.nil?
      signature, desc = parse_head(head)
      
      [desc, signature, body]
    end
    
    def parse_head(head)
      found_signature = false
      head.split("\n").partition do |line|
        found_signature = true if line =~ /^\s*\(.*?\)/
        found_signature
      end
    end
    
    def method_name(name)
      case name
      when /_check$/ then name.sub(/_check$/, '?')
      when /_bang$/  then name.sub(/_bang$/, '!')
      else name
      end
    end
    
    MODULE_TEMPLATE_LINE = __LINE__ + 2
    MODULE_TEMPLATE = "self." + ERB.new(<<-DOC, nil, '<>').src
require 'erb'
<%= sections[:header] %>

# Generated by LineCook, do not edit.
<% module_nest(const_name, '') do %>
<%= sections[:head] %>
<% definitions.each do |definition| %>

<%= definition %>
<% end %>
<%= sections[:tail] %>
<% end %>

<%= sections[:footer] %>
DOC
    
    ERB_TEMPLATE_LINE = __LINE__ + 2
    ERB_TEMPLATE = ERB.new(<<-DOC, nil, '<>').src
# :stopdoc:
<%= name.upcase %>_LINE = __LINE__ + 2
<%= name.upcase %> = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<%= body %>

END_OF_TEMPLATE
# :startdoc:

<% desc.each do |line| %>
# <%= line %>
<% end %>
def <%= method_name(name) %><%= signature %>
  eval(<%= name.upcase %>, binding, __FILE__, <%= name.upcase %>_LINE)
  nil
end

def _<%= method_name(name) %>(*args, &block) # :nodoc:
  capture { <%= method_name(name) %>(*args, &block) }
end
DOC
    
    RB_TEMPLATE_LINE = __LINE__ + 2
    RB_TEMPLATE = ERB.new(<<-DOC, nil, '<>').src
<% desc.each do |line| %>
# <%= line %>
<% end %>
def <%= method_name(name) %><%= signature %>
<%= body.rstrip %>

end

def _<%= method_name(name) %>(*args, &block) # :nodoc:
  capture { <%= method_name(name) %>(*args, &block) }
end
DOC
  end
end