require 'erb'
require 'line_cook/utils'
require 'lazydoc/utils'

# Generated by LineCook, do not edit.

module LineCook
module Helpers
module Bash
include LineCook::Utils

DEFAULT_BASH_PATH = '/bin/bash'
DEFAULT_ENV_PATH  = '/usr/bin/env'

TARGET_PATH = '$LINECOOK_DIR/%s'

attr_writer :bash_path
attr_writer :env_path

def bash_path
  @bash_path ||= DEFAULT_BASH_PATH
end

def env_path
  @env_path ||= DEFAULT_ENV_PATH
end

def target_path(source_path)
  TARGET_PATH % super
end

def close
  unless closed?
    break_line " (#{target_name}) "
  end
  
  super
end
# :stopdoc:
BREAK_LINE_LINE = __LINE__ + 2
BREAK_LINE = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% n = (76 - comment.length)/2 %>
<%= "#" * n %><%= comment %><%= "#" * n %>

END_OF_TEMPLATE
# :startdoc:

def break_line(comment="")
  eval(BREAK_LINE, binding, __FILE__, BREAK_LINE_LINE)
  nil
end

def _break_line(*args, &block) # :nodoc:
  capture { break_line(*args, &block) }
end

# :stopdoc:
CHECK_STATUS_LINE = __LINE__ + 2
CHECK_STATUS = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
check_status <%= status %> $? $LINENO
END_OF_TEMPLATE
# :startdoc:

# Adds a check after a command that ensures the status is as indicated
def check_status(status=0)
  eval(CHECK_STATUS, binding, __FILE__, CHECK_STATUS_LINE)
  nil
end

def _check_status(*args, &block) # :nodoc:
  capture { check_status(*args, &block) }
end

# :stopdoc:
CHECK_STATUS_FUNCTION_LINE = __LINE__ + 2
CHECK_STATUS_FUNCTION = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
function check_status { if [ $1 -ne $2 ]; then echo "[$2] $0:$3"; exit $2; fi }
END_OF_TEMPLATE
# :startdoc:

# Adds the check status function.
def check_status_function
  eval(CHECK_STATUS_FUNCTION, binding, __FILE__, CHECK_STATUS_FUNCTION_LINE)
  nil
end

def _check_status_function(*args, &block) # :nodoc:
  capture { check_status_function(*args, &block) }
end

# :stopdoc:
CHMOD_LINE = __LINE__ + 2
CHMOD = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% if mode %>
chmod <%= mode %> "<%= target %>"
<% check_status %>
<% end %>
END_OF_TEMPLATE
# :startdoc:

def chmod(target, mode=nil)
  eval(CHMOD, binding, __FILE__, CHMOD_LINE)
  nil
end

def _chmod(*args, &block) # :nodoc:
  capture { chmod(*args, &block) }
end

# :stopdoc:
CHOWN_LINE = __LINE__ + 2
CHOWN = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% if user || group %>
chown <%= user %>:<%= group %> "<%= target %>"
<% check_status %>
<% end %>
END_OF_TEMPLATE
# :startdoc:

def chown(target, user=nil, group=nil)
  eval(CHOWN, binding, __FILE__, CHOWN_LINE)
  nil
end

def _chown(*args, &block) # :nodoc:
  capture { chown(*args, &block) }
end

# :stopdoc:
COMMENT_LINE = __LINE__ + 2
COMMENT = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% Lazydoc::Utils.wrap(str).each do |line| %>
# <%= line %>
<% end %>
END_OF_TEMPLATE
# :startdoc:

# Writes a comment.
def comment(str)
  eval(COMMENT, binding, __FILE__, COMMENT_LINE)
  nil
end

def _comment(*args, &block) # :nodoc:
  capture { comment(*args, &block) }
end

# :stopdoc:
DIRECTORY_LINE = __LINE__ + 2
DIRECTORY = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% not_if _directory?(target) do %>
mkdir -p "<%= target %>"
<% check_status %>
<% end %>
<% chmod(target, options[:mode]) %>
<% chown(target, options[:user], options[:group]) %>

END_OF_TEMPLATE
# :startdoc:

def directory(target, options={})
  eval(DIRECTORY, binding, __FILE__, DIRECTORY_LINE)
  nil
end

def _directory(*args, &block) # :nodoc:
  capture { directory(*args, &block) }
end

# :stopdoc:
DIRECTORY_CHECK_LINE = __LINE__ + 2
DIRECTORY_CHECK = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
[ -d "<%= path %>" ]
END_OF_TEMPLATE
# :startdoc:

def directory?(path)
  eval(DIRECTORY_CHECK, binding, __FILE__, DIRECTORY_CHECK_LINE)
  nil
end

def _directory?(*args, &block) # :nodoc:
  capture { directory?(*args, &block) }
end

# :stopdoc:
ECHO_LINE = __LINE__ + 2
ECHO = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
echo '<%= args.join(" ") %>'
END_OF_TEMPLATE
# :startdoc:

# Echos input
def echo(*args)
  eval(ECHO, binding, __FILE__, ECHO_LINE)
  nil
end

def _echo(*args, &block) # :nodoc:
  capture { echo(*args, &block) }
end

# :stopdoc:
EXECUTE_LINE = __LINE__ + 2
EXECUTE = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<%= cmd %>

<% check_status %>

END_OF_TEMPLATE
# :startdoc:

def execute(cmd)
  eval(EXECUTE, binding, __FILE__, EXECUTE_LINE)
  nil
end

def _execute(*args, &block) # :nodoc:
  capture { execute(*args, &block) }
end

# :stopdoc:
EXPORT_LINE = __LINE__ + 2
EXPORT = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% env.to_a.each do |(key, value)| %>
export <%= key %>=<%= value %>
<% end %><% if block_given? %>
<% indent { yield } %>
<% unset(*env.collect {|(k,v)| k }) %>
<% end %>

END_OF_TEMPLATE
# :startdoc:

# Exports a list of variables.
def export(env=[])
  eval(EXPORT, binding, __FILE__, EXPORT_LINE)
  nil
end

def _export(*args, &block) # :nodoc:
  capture { export(*args, &block) }
end

def file(target, options={})
source = file_path(options[:source] || File.basename(target))
install(source, target, options)
end

def _file(*args, &block) # :nodoc:
  capture { file(*args, &block) }
end

# :stopdoc:
FILE_CHECK_LINE = __LINE__ + 2
FILE_CHECK = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
[ -f "<%= path %>" ]
END_OF_TEMPLATE
# :startdoc:

def file?(path)
  eval(FILE_CHECK, binding, __FILE__, FILE_CHECK_LINE)
  nil
end

def _file?(*args, &block) # :nodoc:
  capture { file?(*args, &block) }
end

# :stopdoc:
GEM_PACKAGE_LINE = __LINE__ + 2
GEM_PACKAGE = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% not_if "gem list -i #{name}#{version_opt} > /dev/null" do %>
gem install <%= name %><%= version_opt %> --no-rdoc --no-ri
<% check_status %>

<% end %>
END_OF_TEMPLATE
# :startdoc:

# Installs a package using RubyGems.
def gem_package(name, version=nil)
  version_opt = blank?(version) ? nil : " -v #{version}"
  eval(GEM_PACKAGE, binding, __FILE__, GEM_PACKAGE_LINE)
  nil
end

def _gem_package(*args, &block) # :nodoc:
  capture { gem_package(*args, &block) }
end

# :stopdoc:
GROUP_CHECK_LINE = __LINE__ + 2
GROUP_CHECK = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
grep "^<%= name %>:" /etc/group
END_OF_TEMPLATE
# :startdoc:

def group?(name)
  eval(GROUP_CHECK, binding, __FILE__, GROUP_CHECK_LINE)
  nil
end

def _group?(*args, &block) # :nodoc:
  capture { group?(*args, &block) }
end

# :stopdoc:
GROUPADD_LINE = __LINE__ + 2
GROUPADD = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% not_if _group?(name) do %>
/usr/sbin/groupadd <%= name %>
<% check_status %>
<% end %>

END_OF_TEMPLATE
# :startdoc:

def groupadd(name)
  eval(GROUPADD, binding, __FILE__, GROUPADD_LINE)
  nil
end

def _groupadd(*args, &block) # :nodoc:
  capture { groupadd(*args, &block) }
end

# :stopdoc:
GROUPMOD_LINE = __LINE__ + 2
GROUPMOD = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% users.each do |user| %>
<% not_if "id #{user} | grep -w #{name}" do %>
/usr/sbin/groupmod <%= name %> -A <%= user %>
<% check_status %>
<% end %>
<% end %>
END_OF_TEMPLATE
# :startdoc:

def groupmod(name, options={})
  users = options[:users] || []
  eval(GROUPMOD, binding, __FILE__, GROUPMOD_LINE)
  nil
end

def _groupmod(*args, &block) # :nodoc:
  capture { groupmod(*args, &block) }
end

# :stopdoc:
HEREDOC_LINE = __LINE__ + 2
HEREDOC = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% end_of_file = "END_OF_FILE_#{(@heredoc_count ||= 0) += 1}" %> << <%= end_of_file %>
<% yield %>

<%= end_of_file %>
END_OF_TEMPLATE
# :startdoc:

# Makes a heredoc statement surrounding the contents of the block.
def heredoc
  eval(HEREDOC, binding, __FILE__, HEREDOC_LINE)
  nil
end

def _heredoc(*args, &block) # :nodoc:
  capture { heredoc(*args, &block) }
end

# :stopdoc:
INSTALL_LINE = __LINE__ + 2
INSTALL = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% only_if %Q{#{_file?(target)} && ! cmp -s "#{source}" "#{target}"} do %>
mv "<%= target %>" "$LINECOOK_BACKUP_DIR/$(basename "<%= target %>").$(date '+%Y%m%d.%H%M%S.%N')"
<% check_status %>
<% end %>
cp "<%= source %>" "<%= target %>"
<% check_status %>
<% chmod(target, options[:mode]) %>
<% chown(target, options[:user], options[:group]) %>

END_OF_TEMPLATE
# :startdoc:

def install(source, target, options={})
  eval(INSTALL, binding, __FILE__, INSTALL_LINE)
  nil
end

def _install(*args, &block) # :nodoc:
  capture { install(*args, &block) }
end

# :stopdoc:
LINK_CHECK_LINE = __LINE__ + 2
LINK_CHECK = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
ls -l "<%= target %>" | grep "<%= source %>"
END_OF_TEMPLATE
# :startdoc:

def link?(source, target)
  eval(LINK_CHECK, binding, __FILE__, LINK_CHECK_LINE)
  nil
end

def _link?(*args, &block) # :nodoc:
  capture { link?(*args, &block) }
end

# :stopdoc:
LN_S_LINE = __LINE__ + 2
LN_S = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
ln -sf "<%= source %>" "<%= target %>"
<% check_status %>

END_OF_TEMPLATE
# :startdoc:

def ln_s(source, target)
  eval(LN_S, binding, __FILE__, LN_S_LINE)
  nil
end

def _ln_s(*args, &block) # :nodoc:
  capture { ln_s(*args, &block) }
end

def not_if(cmd, &block)
only_if("! #{cmd}", &block)
end

def _not_if(*args, &block) # :nodoc:
  capture { not_if(*args, &block) }
end

# :stopdoc:
ONLY_IF_LINE = __LINE__ + 2
ONLY_IF = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
if <%= cmd %>
then
<% indent { yield } %>
fi

END_OF_TEMPLATE
# :startdoc:

def only_if(cmd)
  eval(ONLY_IF, binding, __FILE__, ONLY_IF_LINE)
  nil
end

def _only_if(*args, &block) # :nodoc:
  capture { only_if(*args, &block) }
end

# :stopdoc:
PACKAGE_LINE = __LINE__ + 2
PACKAGE = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
zypper -n --no-gpg-checks install -l <%= name %><%= blank?(version) ? nil : "=#{version}" %>
<%= check_status %>

END_OF_TEMPLATE
# :startdoc:

# Installs a package using zypper.
def package(name, version=nil)
  eval(PACKAGE, binding, __FILE__, PACKAGE_LINE)
  nil
end

def _package(*args, &block) # :nodoc:
  capture { package(*args, &block) }
end

# :stopdoc:
QUIET_LINE = __LINE__ + 2
QUIET = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
set +x +v
<% indent { yield } %>
set $LINECOOK_OPTIONS > /dev/null

END_OF_TEMPLATE
# :startdoc:

def quiet(&block)
  eval(QUIET, binding, __FILE__, QUIET_LINE)
  nil
end

def _quiet(*args, &block) # :nodoc:
  capture { quiet(*args, &block) }
end

# :stopdoc:
RECIPE_LINE = __LINE__ + 2
RECIPE = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
"<%= env_path %>" - "<%= bash_path %>" "<%= recipe_path(name, &block) %>" $*
<% check_status %>

END_OF_TEMPLATE
# :startdoc:

def recipe(name, &block)
  eval(RECIPE, binding, __FILE__, RECIPE_LINE)
  nil
end

def _recipe(*args, &block) # :nodoc:
  capture { recipe(*args, &block) }
end

# :stopdoc:
RM_LINE = __LINE__ + 2
RM = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% only_if %Q{ls -l "#{path}"} do %>
rm <% if opts %><%= opts %> <% end %>"<%= path %>"
<% end %>
END_OF_TEMPLATE
# :startdoc:

def rm(path, opts=nil)
  eval(RM, binding, __FILE__, RM_LINE)
  nil
end

def _rm(*args, &block) # :nodoc:
  capture { rm(*args, &block) }
end

def rm_r(path)
rm(path, '-r')
end

def _rm_r(*args, &block) # :nodoc:
  capture { rm_r(*args, &block) }
end

def rm_rf(path)
rm(path, '-rf')
end

def _rm_rf(*args, &block) # :nodoc:
  capture { rm_rf(*args, &block) }
end

# :stopdoc:
SET_LINE = __LINE__ + 2
SET = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% if block_given? %>
<% reset_file = "LINECOOK_RESET_OPTIONS_#{next_count}" %>
<%= reset_file %>=`mktemp /tmp/line_cook_reset_fileXXXXXX`
set -o | sed 's/\(.*\)	on/set -o \1/' | sed 's/\(.*\)	off/set +o \1/' > $<%= reset_file %>
<% end %><% options.keys.sort_by {|opt| opt.to_s }.each do |opt| %>
set <%= options[opt] ? '-' : '+' %>o <%= opt %>
<% end %>
<% if block_given? %>

<% indent { yield }  %>

source $<%= reset_file %>
<% end %>

END_OF_TEMPLATE
# :startdoc:

# Sets bash options for the duration of a block.  If no block is given, set simply
# sets the options as specified.
def set(options)
  eval(SET, binding, __FILE__, SET_LINE)
  nil
end

def _set(*args, &block) # :nodoc:
  capture { set(*args, &block) }
end

# :stopdoc:
SHEBANG_LINE = __LINE__ + 2
SHEBANG = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
#! <%= bash_path %>

<%= break_line %>
<%= check_status_function %>

export -f check_status
export LINECOOK_DIR=$(dirname $0)
export LINECOOK_BACKUP_DIR=/var/linecook/backup
export LINECOOK_OPTIONS=

while getopts bhvx opt
do
  case $opt in
  b)  export LINECOOK_BACKUP_DIR="$OPTARG";;
  v)  LINECOOK_OPTIONS="$LINECOOK_OPTIONS -v";;
  x)  LINECOOK_OPTIONS="$LINECOOK_OPTIONS -x";;
  h)  printf "Usage: %s: [-hvx]\n" $0
      printf "  -h    prints this help\n"
      printf "  -v    verbose (set -v)\n"
      printf "  -x    xtrace  (set -x)\n"
      exit 0;;
  ?)  printf "Usage: %s: [-hvx]\n" $0
      exit 2;;
  esac
done

mkdir -p "$LINECOOK_BACKUP_DIR"
set $LINECOOK_OPTIONS > /dev/null
<%= break_line " #{target_name} " %>

END_OF_TEMPLATE
# :startdoc:

# == Notes Use dev/null on set such that no options will not dump ENV into stdout.
def shebang(bash_path=DEFAULT_BASH_PATH, env_path=DEFAULT_ENV_PATH)
  @bash_path = bash_path
  @env_path  = env_path
  eval(SHEBANG, binding, __FILE__, SHEBANG_LINE)
  nil
end

def _shebang(*args, &block) # :nodoc:
  capture { shebang(*args, &block) }
end

# :stopdoc:
SU_LINE = __LINE__ + 2
SU = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
su <%= user %> "<%= script_path(user, &block) %>"
<% check_status %>

END_OF_TEMPLATE
# :startdoc:

# Switches to a different user for the duration of a block.
def su(user=nil, &block)
  eval(SU, binding, __FILE__, SU_LINE)
  nil
end

def _su(*args, &block) # :nodoc:
  capture { su(*args, &block) }
end

def template(target, options={})
locals = options[:locals] || {:attrs => attrs}
source = template_path(options[:source] || File.basename(target), locals)
install(source, target, options)
end

def _template(*args, &block) # :nodoc:
  capture { template(*args, &block) }
end

# :stopdoc:
UNSET_LINE = __LINE__ + 2
UNSET = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% keys.each do |key| %>
unset <%= key %>
<% end %>
END_OF_TEMPLATE
# :startdoc:

# Unsets a list of variables.
def unset(*keys)
  eval(UNSET, binding, __FILE__, UNSET_LINE)
  nil
end

def _unset(*args, &block) # :nodoc:
  capture { unset(*args, &block) }
end

# :stopdoc:
USER_CHECK_LINE = __LINE__ + 2
USER_CHECK = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
grep "^<%= name %>:" /etc/passwd
END_OF_TEMPLATE
# :startdoc:

def user?(name)
  eval(USER_CHECK, binding, __FILE__, USER_CHECK_LINE)
  nil
end

def _user?(*args, &block) # :nodoc:
  capture { user?(*args, &block) }
end

# :stopdoc:
USERADD_LINE = __LINE__ + 2
USERADD = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% not_if _user?(name) do %>
/usr/sbin/useradd <%= name %> -m
<% check_status %>
<% end %>

END_OF_TEMPLATE
# :startdoc:

def useradd(name)
  eval(USERADD, binding, __FILE__, USERADD_LINE)
  nil
end

def _useradd(*args, &block) # :nodoc:
  capture { useradd(*args, &block) }
end

end
end
end
