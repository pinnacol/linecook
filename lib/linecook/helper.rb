require 'linecook/template'

module Linecook
  class Helper < Template
    attr_reader :const_name
    attr_reader :sources
    
    def initialize(const_name, sources)
      @const_name = const_name
      @sources    = sources.select {|source| File.file?(source) }
      @section_paths, @definition_paths = @sources.partition {|path| File.basename(path)[0] == ?_ }
      super()
    end
    
    def build
      eval MODULE_TEMPLATE, binding, __FILE__, MODULE_TEMPLATE_LINE
      result
    end
    
    def sections
      @sections ||= begin
        sections = {}
        
        @section_paths.each do |path|
          key = File.basename(path)[1..-1]
          key.chomp! File.extname(path)
          sections[key.to_sym] = File.read(path)
        end
        
        sections
      end
    end
    
    def definitions
      @definitions ||= @definition_paths.collect do |path|
        name = File.basename(path).chomp File.extname(path)
        desc, signature, body = parse File.read(path)
        
        case File.extname(path)
        when '.erb'
          eval ERB_TEMPLATE, binding, __FILE__, ERB_TEMPLATE_LINE
        when '.rb'
          eval RB_TEMPLATE, binding, __FILE__, RB_TEMPLATE_LINE
        else
          raise "invalid definition file: #{path.inspect}"
        end
      end
    end
    
    private
    
    def parse(str)
      head, body = str.split(/^--.*\n/, 2)
      head, body = '', head if body.nil?
      signature, desc = parse_head(head)
      
      [desc.join("\n"), signature.join("\n"), body]
    end
    
    def parse_head(head)
      found_signature = false
      head.split("\n").partition do |line|
        found_signature = true if line =~ /^\s*\(.*?\)/
        found_signature
      end
    end
    
    def method_name(name)
      case name
      when /_check$/ then name.sub(/_check$/, '?')
      when /_bang$/  then name.sub(/_bang$/, '!')
      else name
      end
    end
    
    def module_nest(const_name, indent="  ", line_sep="\n")
      nestings = const_name.split(/::/).collect {|name| ["module #{name}", "end"]} 
      nestings << {:indent => indent, :line_sep => line_sep}
      
      nest(*nestings) { yield }
    end
    
    MODULE_TEMPLATE_LINE = __LINE__ + 2
    MODULE_TEMPLATE = "self." + ERB.new(<<-DOC, nil, '<>').src
require 'erb'
<%= sections[:header] %>

# Generated by Linecook, do not edit.
<% module_nest(const_name, '') do %>
<%= sections[:head] %>
<% definitions.each do |definition| %>

<%= definition %>
<% end %>
<%= sections[:tail] %>
<% end %>

<%= sections[:footer] %>
DOC
    
    ERB_TEMPLATE_LINE = __LINE__ + 2
    ERB_TEMPLATE = ERB.new(<<-DOC, nil, '<>').src
# :stopdoc:
<%= name.upcase %>_LINE = __LINE__ + 2
<%= name.upcase %> = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<%= body %>

END_OF_TEMPLATE
# :startdoc:

<% desc.each do |line| %>
# <%= line %>
<% end %>
def <%= method_name(name) %><%= signature %>
  eval(<%= name.upcase %>, binding, __FILE__, <%= name.upcase %>_LINE)
  nil
end

def _<%= method_name(name) %>(*args, &block) # :nodoc:
  capture { <%= method_name(name) %>(*args, &block) }
end
DOC

    RB_TEMPLATE_LINE = __LINE__ + 2
    RB_TEMPLATE = ERB.new(<<-DOC, nil, '<>').src
<% desc.each do |line| %>
# <%= line %>
<% end %>
def <%= method_name(name) %><%= signature %>
  <%= body %>
end

def _<%= method_name(name) %>(*args, &block) # :nodoc:
  capture { <%= method_name(name) %>(*args, &block) }
end
DOC
  end
end