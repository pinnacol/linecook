require 'linecook/template'

module Linecook
  
  # == Source Files
  #
  # The contents of the source file are translated into code according to
  # the source file extname.
  #
  #   extname      translation
  #   .rb          file defines method body
  #   .erb         file defines an ERB template (compiled to ruby code)
  #
  # Source files can specify documenation and a method signature using a
  # standard header separated from the body by a double-dash.  For example
  # this:
  #
  #   [echo.erb]
  #   Echo arguments out to the target.
  #   (*args)
  #   --
  #   echo <%= args.join(' ') %>
  #
  # Is translated into something like:
  #
  #   # Echo arguments out to the target.
  #   def echo(*args)
  #     eval ERB.new("echo <%= args.join(' ') %>").src
  #   end
  #
  # Check and bang methods can be specified by adding -check and -bang to
  # the end of the file name.  These extensions are stripped off like:
  #
  #   [file-check.erb]   # => def file? ...
  #   [make-bang.rb]     # => def make! ...
  #
  # == Section Files
  #
  # Special section files can be used to define non-standard code in the
  # following places:
  #
  #   [:header]
  #   module Name
  #     [:head]
  #     ...
  #     [:foot]
  #   end
  #   [:footer]
  #
  # Section files are defined by adding -section.rb at the end of the file
  # name (like header-section.rb) and are not processed like other source
  # files; the contents are directly transcribed.
  class Helper < Template
    attr_reader :const_name
    attr_reader :sources
    
    def initialize(const_name, sources)
      @const_name = const_name
      @sources    = sources.select {|source| File.file?(source) }
      @section_paths, @definition_paths = @sources.partition {|path| path =~ /\-section\.rb$/ }
      super()
    end
    
    def build
      eval MODULE_TEMPLATE, binding, __FILE__, MODULE_TEMPLATE_LINE
      result
    end
    
    def sections
      @sections ||= begin
        sections = {}
        
        @section_paths.each do |path|
          key = File.basename(path).chomp!('-section.rb')
          sections[key.to_sym] = File.read(path)
        end
        
        sections
      end
    end
    
    def definitions
      @definitions ||= @definition_paths.collect {|path| parse(path) }
    end
    
    private
    
    def parse(path)
      extname = File.extname(path)
      name = File.basename(path).chomp(extname)
      
      head, body = File.read(path).split(/^--.*\n/, 2)
      head, body = '', head if body.nil?
      signature, desc = parse_head(head)
      
      [name, desc, signature.join("\n"), body, extname]
    end
    
    def format(body, extname)
      case extname
      when '.erb'
        source = "#  #{body.gsub(/\n/, "\n#  ")}"
        code   = ERB.new(body, nil, '<>').src
        
        if code =~ /\A_erbout = '';\s*(.*?)\s*_erbout\z/m
          code = $1
        end
        
        "#{source}\n#{code}".gsub(/^(\s*)/) do |m| 
          indent = 2 + $1.length - ($1.length % 2)
          ' ' * indent
        end
        
      when '.rb'
        body
        
      else
        raise "invalid definition format: #{extname.inspect}"
      end
    end
    
    def parse_head(head)
      found_signature = false
      head.split("\n").partition do |line|
        found_signature = true if line =~ /^\s*\(.*?\)/
        found_signature
      end
    end
    
    def method_name(name)
      case name
      when /-check$/ then name.sub(/-check$/, '?')
      when /-bang$/  then name.sub(/-bang$/, '!')
      else name
      end
    end
    
    def module_nest(const_name, indent="  ", line_sep="\n")
      nestings = const_name.split(/::/).collect {|name| ["module #{name}", "end"]} 
      nestings << {:indent => indent, :line_sep => line_sep}
      
      nest(*nestings) { yield }
    end
    
    MODULE_TEMPLATE_LINE = __LINE__ + 2
    MODULE_TEMPLATE = "self." + ERB.new(<<-DOC, nil, '<>').src
require 'erb'
<%= sections[:header] %>

# Generated by Linecook, do not edit.
<% module_nest(const_name) do %>
<%= sections[:head].to_s.strip %>

<% definitions.each do |name, desc, signature, body, extname| %>

<% desc.each do |line| %>
# <%= line %>
<% end %>
def <%= method_name(name) %><%= signature %>
<%= format(body, extname) %>

  nil
end

def _<%= method_name(name) %>(*args, &block) # :nodoc:
  capture { <%= method_name(name) %>(*args, &block) }
end
<% end %>

<%= sections[:tail].to_s.strip %>
<% end %>

<%= sections[:footer] %>
DOC
  end
end