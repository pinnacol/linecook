require 'linecook/recipe'
require 'tempfile'

module Linecook
  class Package
    class << self
      def init(env={}, cookbook=nil)
        package = new(env)
        
        if cookbook
          if cookbook_config = package.cookbook_config
            cookbook = cookbook.merge(cookbook_config)
          end
          
          package.config[MANIFEST_KEY] ||= cookbook.manifest
        end
        
        package
      end
      
      def load(path=nil, cookbook=nil)
        env = Utils.load_config(path)
        init(env, cookbook)
      end
      
      def setup(env={}, cookbook=nil)
        env.kind_of?(String) ? load(env, cookbook) : init(env, cookbook)
      end
      
      def build(path=nil, cookbook=nil)
        package = load(path, cookbook)
        package.build
        package.close
        package
      end
    end
    
    CONFIG_KEY          = 'linecook'
    COOKBOOK_CONFIG_KEY = 'cookbook'
    MANIFEST_KEY        = 'manifest'
    FILES_KEY           = 'files'
    TEMPLATES_KEY       = 'templates'
    RECIPES_KEY         = 'recipes'
    RESOURCE_TYPES      = [FILES_KEY, TEMPLATES_KEY, RECIPES_KEY]
    
    # The package environment
    attr_reader :env
    
    # An array of tempfiles generated by self (used to cleanup on close)
    attr_reader :tempfiles
    
    # A hash of (target_path, source_path) pairs identifying files that should
    # be included in a package
    attr_reader :registry
    
    # An inverted registry of (source_path, target_path) pairs; entirely
    # redundant but useful for various lookups.
    attr_reader :reverse_registry
    
    # A hash of counters used by variable.
    attr_reader :counters
    
    def initialize(env={})
      @env = env
      @tempfiles = []
      @registry = {}
      @reverse_registry = {}
      @counters = Hash.new(0)
    end
    
    # Returns the linecook configs in env, as keyed by CONFIG_KEY.  Defaults
    # to an empty hash.
    def config
      env[CONFIG_KEY] ||= {}
    end
    
    # Returns the cookbook configs in config, as keyed by COOKBOOK_CONFIG_KEY.
    # Defaults to an empty hash.
    def cookbook_config
      config[COOKBOOK_CONFIG_KEY]
    end
    
    # Returns the manifest in config, as keyed by MANIFEST_KEY. Defaults to an
    # empty hash.
    def manifest
      config[MANIFEST_KEY] ||= Hash.new {|hash, key| hash[key] = {} }
    end
    
    # Returns a hash of (source, target) pairs identifying which of the
    # specified type of resources will be built into self by build.  The type
    # of resource can be 'files', 'templates', or 'recipes'.  Resources are
    # looked up in config by type and then normalized.
    #
    # ==== Normalization
    #
    # Resources are normalized by expanding arrays into a redundant hash, such
    # that each entry has the same source and target (more concretely, the
    # 'example' recipe is registered as the 'example' script).  Strings are
    # split along colons into an array and then expanded.
    #
    # For example:
    #
    #   package = Package.new('linecook' => {'recipes' => 'a:b:c'})
    #   package.resources('recipes')   # => {'a' => 'a', 'b' => 'b', 'c' => 'c'}
    #
    def resources(type)
      unless RESOURCE_TYPES.include?(type)
        raise "invalid type: #{type.inspect}"
      end
      
      obj = config[type]
      
      case obj
      when Hash
        obj
        
      when nil
        config[type] = {}
        
      when Array
        hash = {}
        obj.each {|entry| hash[entry] = entry }
        config[type] = hash
      
      when String
        config[type] = obj.split(':')
        resources(type)
      
      else
        raise "invalid #{type}: #{obj.inspect}"
      end
    end
    
    # Returns the 'files' resources.
    def files
      resources(FILES_KEY)
    end
    
    # Returns the 'templates' resources.
    def templates
      resources(TEMPLATES_KEY)
    end
    
    # Returns the 'recipes' resources.
    def recipes
      resources(RECIPES_KEY)
    end
    
    def [](target_path)
      registry[target_path]
    end
    
    # Registers the source_path to target_path in the registry and
    # revese_registry.  Raises an error if the source_path is already
    # registered.
    def register!(target_path, source_path)
      source_path = File.expand_path(source_path)
      
      if registered_target?(target_path) && source_path(target_path) != source_path
        raise "already registered: #{target_path.inspect}"
      end
      
      registry[target_path] = source_path
      reverse_registry[source_path] = target_path
      
      target_path
    end
    
    # Registers the source_path to target_path in the registry and
    # revese_registry.  Increments and returns the new target_path if the
    # target_path is already a registered target.
    def register(target_path, source_path)
      source_path = File.expand_path(source_path)
      
      count = 0
      registry.each_key do |path|
        if path.kind_of?(String) && path.index(target_path) == 0
          count += 1
        end
      end
      
      if count > 0
        target_path = "#{target_path}.#{count}"
      end
      
      register!(target_path, source_path)
    end
    
    # Returns true if the target_path is registered.
    def registered_target?(target_path)
      registry.has_key?(target_path)
    end
    
    # Returns true if the source_path is registered.
    def registered_source?(source_path)
      source_path = File.expand_path(source_path)
      reverse_registry.has_key?(source_path)
    end
    
    # Returns the source_path registered to target_path.
    def source_path(target_path)
      registry[target_path]
    end
    
    # Returns the latest target_path registered to source_path.
    def target_path(source_path)
      source_path = File.expand_path(source_path)
      reverse_registry[source_path]
    end
    
    # Returns true if there is a path for the specified resource in manifest.
    def resource?(type, path)
      resources = manifest[type]
      resources && resources.has_key?(path)
    end
    
    # Returns the path to the resource in manfiest.  Raises an error if there
    # is no such resource.
    def resource_path(type, path)
      resources = manifest[type] || {}
      resources[path] or raise "no such resource in manifest: #{type.inspect} #{path.inspect}"
    end
    
    # Returns the resource_path the named attributes file (ex 'attributes/name.rb').
    def attributes_path(attributes_name)
      resource_path('attributes', attributes_name)
    end
    
    # Returns the resource_path the named file (ex 'files/name')
    def file_path(file_name)
      resource_path('files', file_name)
    end
    
    # Returns the resource_path the named template file (ex 'templates/name.erb').
    def template_path(template_name)
      resource_path('templates', template_name)
    end
    
    # Returns the resource_path the named recipe file (ex 'recipes/name.rb').
    def recipe_path(recipe_name)
      resource_path('recipes', recipe_name)
    end
    
    # Generates a tempfile for the target path and registers it with self. As
    # with register, the target_path will be incremented as needed.  Returns
    # the open tempfile.
    def tempfile(target_path='tempfile')
      tempfile = Tempfile.new File.basename(target_path)
      
      register(target_path, tempfile.path)
      tempfiles << tempfile
      
      tempfile
    end
    
    # Generates a tempfile for the target path and registers it with self.
    # Returns the open tempfile.  Raises an error if the target_path is
    # already registered.
    def tempfile!(target_path)
      tempfile = Tempfile.new File.basename(target_path)
      
      register!(target_path, tempfile.path)
      tempfiles << tempfile
      
      tempfile
    end
    
    # Returns true if the source_path is for a tempfile generated by self.
    def tempfile?(source_path)
      tempfiles.any? {|tempfile| tempfile.path == source_path }
    end
    
    # Returns a recipe bound to self.
    def recipe(target_path='recipe')
      target = tempfile(target_path)
      Recipe.new(target, self)
    end
    
    # Returns a recipe bound to self with the given target path.  Raises an
    # error if the target is already registered.
    def recipe!(target_path)
      target = tempfile!(target_path)
      Recipe.new(target, self)
    end
    
    def helper(helper_name)
      require Utils.underscore(helper_name)
      Utils.constantize(helper_name)
    end
    
    # Returns a package-unique variable with base 'name'.
    def variable(name)
      name  = name.to_s
      
      count = counters[name]
      counters[name] += 1
      
      "#{name}#{count}"
    end
    
    # Looks up the file with the specified name using file_path and registers
    # it to target_path.  Raises an error if the target is already registered.
    # Returns self.
    def build_file(file_name, target_path)
      register! target_path, file_path(file_name)
      self
    end
    
    # Looks up the template with the specified name using template_path,
    # builds, and registers it to target_path.  The locals will be set for
    # access in the template context.  Raises an error if the target is
    # already registered. Returns self.
    def build_template(template_name, target_path, locals=env)
      source = template_path(template_name)
      
      target = tempfile!(target_path)
      target << Template.build(File.read(source), locals, source)
      
      target.close
      self
    end
    
    # Looks up the recipe with the specified name using recipe_path, evaluates
    # it, and registers the result to target_path.  Raises an error if the
    # target is already registered. Returns self.
    def build_recipe(recipe_name, target_path)
      recipe = self.recipe!(target_path)
      recipe.evaluate(recipe_name)
      
      tempfile = recipe.target
      tempfile.close unless tempfile.closed?
      
      self
    end
    
    # Builds the files, templates, and recipes for self.  Returns self.
    def build
      files.each do |file_name, target_path|
        build_file(file_name, target_path)
      end
      
      templates.each do |template_name, target_path|
        build_template(template_name, target_path)
      end
      
      recipes.each do |recipe_name, target_path|
        build_recipe(recipe_name, target_path)
      end
      
      self
    end
    
    # Returns the content of the source_path for target_path, as registered in
    # self.  Returns nil if the target is not registered.
    def content(target_path, length=nil, offset=nil)
      path = registry[target_path]
      path ? File.read(path, length, offset) : nil
    end
    
    # Closes all tempfiles and returns self.
    def close
      tempfiles.each do |tempfile|
        tempfile.close unless tempfile.closed?
      end
      self
    end
    
    def reset
      close
      tempfiles.clear
      registry.clear
      reverse_registry.clear
      counters.clear
      self
    end
    
    # Closes self and exports the registry to dir by copying or moving the
    # registered source paths to the target path under dir.  By default
    # tempfiles are moved while all other files are copied.
    #
    # Returns registry, which is re-written to reflect the new source paths.
    def export(dir, options={})
      close
      
      options = {
        :allow_move => true
      }.merge(options)
      
      allow_move = options[:allow_move]
      
      registry.each_key do |target_path|
        export_path = File.join(dir, target_path)
        export_dir  = File.dirname(export_path)
        
        unless File.exists?(export_dir)
          FileUtils.mkdir_p(export_dir)
        end
        
        source_path = registry[target_path]
        
        if allow_move && tempfile?(source_path)
          FileUtils.mv(source_path, export_path)
        else
          FileUtils.cp(source_path, export_path)
        end
        
        registry[target_path] = export_path
      end
      
      tempfiles.clear
      registry
    end
  end
end