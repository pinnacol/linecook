# Generated by Linecook

module Linecook
  module Os
    module Posix
      module Utilities
        # Returns an expression that evaluates to the program dir, assuming that
        # $0 evaluates to the full path to the current recipe.
        def program_dir
          '$(dirname "$0")'
        end

        # Return non-directory portion of a pathname. If a suffix is provided and
        # present, then it will be removed.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/basename.html]
        def basename(string, suffix=nil)
          execute 'basename', string, suffix
          _chain_proxy_
        end

        def _basename(*args, &block) # :nodoc:
          str = capture { basename(*args, &block) }
          str.strip!
          str
        end

        # Concatenate and print files.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/cat.html]
        def cat(*files)
          execute 'cat', *files
          _chain_proxy_
        end

        def _cat(*args, &block) # :nodoc:
          str = capture { cat(*args, &block) }
          str.strip!
          str
        end

        # Change the working directory, for the duration of a block if given.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/cd.html]
        def cd(directory=nil, options={})
          if block_given?
            var = _package_.next_variable_name('cd')
            writeln %{#{var}=$(pwd)}
          end

          execute 'cd', directory, options

          if block_given?
            yield
            execute 'cd', "$#{var}"
          end
          _chain_proxy_
        end

        def _cd(*args, &block) # :nodoc:
          str = capture { cd(*args, &block) }
          str.strip!
          str
        end

        # Change the file group ownership
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/chgrp.html]
        def chgrp(group, *files)
          unless group.nil?
            execute 'chgrp', group, *files
          end
          _chain_proxy_
        end

        def _chgrp(*args, &block) # :nodoc:
          str = capture { chgrp(*args, &block) }
          str.strip!
          str
        end

        # Change the file modes. The mode may be specified as a String or a Fixnum. If a
        # Fixnum is provided, then it will be formatted into an octal string using
        # sprintf "%o".
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/chmod.html]
        def chmod(mode, *files)
          unless mode.nil?
            if mode.kind_of?(Fixnum)
              mode = sprintf("%o", mode)
            end
            execute 'chmod', mode, *files
          end
          _chain_proxy_
        end

        def _chmod(*args, &block) # :nodoc:
          str = capture { chmod(*args, &block) }
          str.strip!
          str
        end

        # Change the file ownership.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/chown.html]
        def chown(owner, *files)
          unless owner.nil?
            execute 'chown', owner, *files
          end
          _chain_proxy_
        end

        def _chown(*args, &block) # :nodoc:
          str = capture { chown(*args, &block) }
          str.strip!
          str
        end

        # Compare two files.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/cmp.html]
        def cmp(file1, file2, options={})
          execute 'cmp', file1, file2, options
          _chain_proxy_
        end

        def _cmp(*args, &block) # :nodoc:
          str = capture { cmp(*args, &block) }
          str.strip!
          str
        end

        # Select or reject lines common to two files.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/comm.html]
        def comm(file1, file2, options={})
          execute 'comm', file1, file2, options
          _chain_proxy_
        end

        def _comm(*args, &block) # :nodoc:
          str = capture { comm(*args, &block) }
          str.strip!
          str
        end

        # Copy files.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/cp.html]
        def cp(source_file, target_file, options={})
          execute 'cp', source_file, target_file, options
          _chain_proxy_
        end

        def _cp(*args, &block) # :nodoc:
          str = capture { cp(*args, &block) }
          str.strip!
          str
        end

        # Cut out selected fields of each line of a file.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/cut.html]
        def cut(*files)
          execute 'cut', *files
          _chain_proxy_
        end

        def _cut(*args, &block) # :nodoc:
          str = capture { cut(*args, &block) }
          str.strip!
          str
        end

        # Writes the date and time.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/date.html]
        def date(options={})
          execute 'date', options
          _chain_proxy_
        end

        def _date(*args, &block) # :nodoc:
          str = capture { date(*args, &block) }
          str.strip!
          str
        end

        # Checks that file exists and is a directory.
        def directory?(dir)
          #  [ -d "<%= dir %>" ]
          #  
          write "[ -d \""; write(( dir ).to_s); write "\" ]\n"

          _chain_proxy_
        end

        def _directory?(*args, &block) # :nodoc:
          str = capture { directory?(*args, &block) }
          str.strip!
          str
        end

        # Return the directory portion of a pathname.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/dirname.html]
        def dirname(string)
          execute 'dirname', string
          _chain_proxy_
        end

        def _dirname(*args, &block) # :nodoc:
          str = capture { dirname(*args, &block) }
          str.strip!
          str
        end

        # Write arguments to standard output.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/echo.html]
        def echo(*string)
          execute 'echo', *string
          _chain_proxy_
        end

        def _echo(*args, &block) # :nodoc:
          str = capture { echo(*args, &block) }
          str.strip!
          str
        end

        # Checks that file exists and is executable, or file is a directory that can be
        # searched.
        def executable?(file)
          #  [ -x "<%= file %>" ]
          #  
          write "[ -x \""; write(( file ).to_s); write "\" ]\n"

          _chain_proxy_
        end

        def _executable?(*args, &block) # :nodoc:
          str = capture { executable?(*args, &block) }
          str.strip!
          str
        end

        # Checks that file exists.
        def exists?(file)
          #  [ -e "<%= file %>" ]
          #  
          write "[ -e \""; write(( file ).to_s); write "\" ]\n"

          _chain_proxy_
        end

        def _exists?(*args, &block) # :nodoc:
          str = capture { exists?(*args, &block) }
          str.strip!
          str
        end

        # Convert tabs to spaces.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/expand.html]
        def expand(*files)
          execute 'expand', *files
          _chain_proxy_
        end

        def _expand(*args, &block) # :nodoc:
          str = capture { expand(*args, &block) }
          str.strip!
          str
        end

        # Set the export attribute for variables.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_22]
        def export(key, value=nil)
          #  <% if value.nil? %>
          #  export <%= key %>
          #  <% else %>
          #  export <%= key %>=<%= quote(value) %>
          #  <% end %>
          #  
          if value.nil? 
          write "export "; write(( key ).to_s); write "\n"
          else 
          write "export "; write(( key ).to_s); write "="; write(( quote(value) ).to_s); write "\n"
          end 

          _chain_proxy_
        end

        def _export(*args, &block) # :nodoc:
          str = capture { export(*args, &block) }
          str.strip!
          str
        end

        # Checks that file exists and is a regular file.
        def file?(file)
          #  [ -f "<%= file %>" ]
          #  
          write "[ -f \""; write(( file ).to_s); write "\" ]\n"

          _chain_proxy_
        end

        def _file?(*args, &block) # :nodoc:
          str = capture { file?(*args, &block) }
          str.strip!
          str
        end

        # Filter for folding lines.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/fold.html]
        def fold(*files)
          execute 'fold', *files
          _chain_proxy_
        end

        def _fold(*args, &block) # :nodoc:
          str = capture { fold(*args, &block) }
          str.strip!
          str
        end

        # Search a file for a pattern.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/grep.html]
        def grep(pattern_list, *files)
          execute 'grep', pattern_list, *files
          _chain_proxy_
        end

        def _grep(*args, &block) # :nodoc:
          str = capture { grep(*args, &block) }
          str.strip!
          str
        end

        # Checks that file exists and is not empty.
        def has_content?(file)
          #  [ -s "<%= file %>" ]
          #  
          write "[ -s \""; write(( file ).to_s); write "\" ]\n"

          _chain_proxy_
        end

        def _has_content?(*args, &block) # :nodoc:
          str = capture { has_content?(*args, &block) }
          str.strip!
          str
        end

        # Copy the first part of files.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/head.html]
        def head(*files)
          execute 'head', *files
          _chain_proxy_
        end

        def _head(*args, &block) # :nodoc:
          str = capture { head(*args, &block) }
          str.strip!
          str
        end

        # Return user identity.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/id.html]
        def id(user, options={})
          execute 'id', user, options
          _chain_proxy_
        end

        def _id(*args, &block) # :nodoc:
          str = capture { id(*args, &block) }
          str.strip!
          str
        end

        # Checks that file exists and is a symbolic link.
        def link?(file)
          #  [ -L "<%= file %>" ]
          #  
          write "[ -L \""; write(( file ).to_s); write "\" ]\n"

          _chain_proxy_
        end

        def _link?(*args, &block) # :nodoc:
          str = capture { link?(*args, &block) }
          str.strip!
          str
        end

        # Link files.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/ln.html]
        def ln(source_file, target_file, options={})
          execute 'ln', source_file, target_file, options
          _chain_proxy_
        end

        def _ln(*args, &block) # :nodoc:
          str = capture { ln(*args, &block) }
          str.strip!
          str
        end

        # List directory contents.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/ls.html]
        def ls(*files)
          execute 'ls', *files
          _chain_proxy_
        end

        def _ls(*args, &block) # :nodoc:
          str = capture { ls(*args, &block) }
          str.strip!
          str
        end

        # Make directories.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/mkdir.html]
        def mkdir(*dirs)
          execute 'mkdir', *dirs
          _chain_proxy_
        end

        def _mkdir(*args, &block) # :nodoc:
          str = capture { mkdir(*args, &block) }
          str.strip!
          str
        end

        # Move files.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/mv.html]
        def mv(source_file, target_file, options={})
          execute 'mv', source_file, target_file, options
          _chain_proxy_
        end

        def _mv(*args, &block) # :nodoc:
          str = capture { mv(*args, &block) }
          str.strip!
          str
        end

        # Merge corresponding or subsequent lines of files.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/paste.html]
        def paste(*files)
          execute 'paste', *files
          _chain_proxy_
        end

        def _paste(*args, &block) # :nodoc:
          str = capture { paste(*args, &block) }
          str.strip!
          str
        end

        # Check pathnames.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/pathchk.html]
        def pathchk(*pathnames)
          execute 'pathchk', *pathnames
          _chain_proxy_
        end

        def _pathchk(*args, &block) # :nodoc:
          str = capture { pathchk(*args, &block) }
          str.strip!
          str
        end

        # Return working directory name.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/pwd.html]
        def pwd(options={})
          execute 'pwd', options
          _chain_proxy_
        end

        def _pwd(*args, &block) # :nodoc:
          str = capture { pwd(*args, &block) }
          str.strip!
          str
        end

        # Read a line from standard input.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/read.html]
        def read(*vars)
          execute 'read', *vars
          _chain_proxy_
        end

        def _read(*args, &block) # :nodoc:
          str = capture { read(*args, &block) }
          str.strip!
          str
        end

        # Checks that file exists and is readable.
        def readable?(file)
          #  [ -r "<%= file %>" ]
          #  
          write "[ -r \""; write(( file ).to_s); write "\" ]\n"

          _chain_proxy_
        end

        def _readable?(*args, &block) # :nodoc:
          str = capture { readable?(*args, &block) }
          str.strip!
          str
        end

        # Remove directory entries.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/rm.html]
        def rm(*files)
          execute 'rm', *files
          _chain_proxy_
        end

        def _rm(*args, &block) # :nodoc:
          str = capture { rm(*args, &block) }
          str.strip!
          str
        end

        # Remove directories.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/rmdir.html]
        def rmdir(*dirs)
          execute 'rm', *dirs
          _chain_proxy_
        end

        def _rmdir(*args, &block) # :nodoc:
          str = capture { rmdir(*args, &block) }
          str.strip!
          str
        end

        # Stream editor.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/sed.html]
        def sed(script, *files)
          execute 'sed', script, *files
          _chain_proxy_
        end

        def _sed(*args, &block) # :nodoc:
          str = capture { sed(*args, &block) }
          str.strip!
          str
        end

        # Set or unset options as specified. For example:
        # 
        #   set 'x' => true, 'v' => false
        # 
        # If a block is given then options will only be reset when the block completes.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_25]
        def set(options)
          if block_given?
            var = _package_.next_variable_name('set')
            patterns = options.keys.collect {|key| "-e #{key}" }.sort
            writeln %{#{var}=$(set +o | grep #{patterns.join(' ')})}
          end

          options.keys.sort_by {|opt| opt.to_s }.each do |opt|
            writeln %{set #{options[opt] ? '-' : '+'}o #{opt}}
          end

          if block_given?
            yield
            writeln %{eval "$#{var}"}
          end
          _chain_proxy_
        end

        def _set(*args, &block) # :nodoc:
          str = capture { set(*args, &block) }
          str.strip!
          str
        end

        # Sort, merge, or sequence check text files.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/sort.html]
        def sort(*files)
          execute 'sort', *files
          _chain_proxy_
        end

        def _sort(*args, &block) # :nodoc:
          str = capture { sort(*args, &block) }
          str.strip!
          str
        end

        # Split files into pieces.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/split.html]
        def split(file, *options)
          execute 'split', file, *options
          _chain_proxy_
        end

        def _split(*args, &block) # :nodoc:
          str = capture { split(*args, &block) }
          str.strip!
          str
        end

        # Copy the last part of a file.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/tail.html]
        def tail(file, options={})
          execute 'tail', file, options
          _chain_proxy_
        end

        def _tail(*args, &block) # :nodoc:
          str = capture { tail(*args, &block) }
          str.strip!
          str
        end

        # Change file access and modification times.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/touch.html]
        def touch(*files)
          execute 'touch', *files
          _chain_proxy_
        end

        def _touch(*args, &block) # :nodoc:
          str = capture { touch(*args, &block) }
          str.strip!
          str
        end

        # Translate characters.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/tr.html]
        def tr(string1, string2=nil, *options)
          execute 'tr', string1, string2, *options
          _chain_proxy_
        end

        def _tr(*args, &block) # :nodoc:
          str = capture { tr(*args, &block) }
          str.strip!
          str
        end

        # Topological sort.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/tsort.html]
        def tsort(file)
          execute 'tsort', file
          _chain_proxy_
        end

        def _tsort(*args, &block) # :nodoc:
          str = capture { tsort(*args, &block) }
          str.strip!
          str
        end

        # Return system name.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/uname.html]
        def uname(options={})
          execute 'uname', options
          _chain_proxy_
        end

        def _uname(*args, &block) # :nodoc:
          str = capture { uname(*args, &block) }
          str.strip!
          str
        end

        # Convert spaces to tabs.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/unexpand.html]
        def unexpand(*files)
          execute 'unexpand', *files
          _chain_proxy_
        end

        def _unexpand(*args, &block) # :nodoc:
          str = capture { unexpand(*args, &block) }
          str.strip!
          str
        end

        # Report or filter out repeated lines in a file.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/uniq.html]
        def uniq(*options)
          execute 'uniq', *options
          _chain_proxy_
        end

        def _uniq(*args, &block) # :nodoc:
          str = capture { uniq(*args, &block) }
          str.strip!
          str
        end

        # Unset values and attributes of variables and functions.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_29]
        def unset(*names)
          execute 'unset', *names
          _chain_proxy_
        end

        def _unset(*args, &block) # :nodoc:
          str = capture { unset(*args, &block) }
          str.strip!
          str
        end

        # Word, line, and byte or character count.
        # {[Spec]}[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/wc.html]
        def wc(*files)
          execute 'wc', *files
          _chain_proxy_
        end

        def _wc(*args, &block) # :nodoc:
          str = capture { wc(*args, &block) }
          str.strip!
          str
        end

        # Checks that file exists and is writable.
        def writable?(file)
          #  [ -w "<%= file %>" ]
          #  
          write "[ -w \""; write(( file ).to_s); write "\" ]\n"

          _chain_proxy_
        end

        def _writable?(*args, &block) # :nodoc:
          str = capture { writable?(*args, &block) }
          str.strip!
          str
        end
      end
    end
  end
end
