require 'erb'

# Generated by Linecook, do not edit.
module Linecook
module Shell
module Utils
require 'linecook/shell/posix'
include Posix
# :stopdoc:
BREAK_LINE_LINE = __LINE__ + 2
BREAK_LINE = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% n = (76 - comment.length)/2 %>
<%= "#" * n %><%= comment %><%= "#" * n %>

END_OF_TEMPLATE
# :startdoc:

def break_line(comment="")
  eval(BREAK_LINE, binding, __FILE__, BREAK_LINE_LINE)
  nil
end

def _break_line(*args, &block) # :nodoc:
  capture { break_line(*args, &block) }
end

# :stopdoc:
CHECK_STATUS_LINE = __LINE__ + 2
CHECK_STATUS = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
check_status <%= status %> $? $LINENO
END_OF_TEMPLATE
# :startdoc:

# Adds a check after a command that ensures the status is as indicated
def check_status(status=0)
  eval(CHECK_STATUS, binding, __FILE__, CHECK_STATUS_LINE)
  nil
end

def _check_status(*args, &block) # :nodoc:
  capture { check_status(*args, &block) }
end

# :stopdoc:
CHECK_STATUS_FUNCTION_LINE = __LINE__ + 2
CHECK_STATUS_FUNCTION = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
function check_status { if [ $1 -ne $2 ]; then echo "[$2] $0:$3"; exit $2; fi }
END_OF_TEMPLATE
# :startdoc:

# Adds the check status function.
def check_status_function
  eval(CHECK_STATUS_FUNCTION, binding, __FILE__, CHECK_STATUS_FUNCTION_LINE)
  nil
end

def _check_status_function(*args, &block) # :nodoc:
  capture { check_status_function(*args, &block) }
end
end
end
end
