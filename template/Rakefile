require 'rake'

#
# VirtualBox Tasks
#

VMNAME  = ENV['LINE_COOK_VM_NAME'] || 'vbox'
VUSER   = ENV['LINE_COOK_VM_USER'] || 'vbox'
KEYPATH = File.expand_path('../vbox/ssh/id_rsa', __FILE__)

desc "start the #{VMNAME} vm"
task :start do
  type = ENV['TYPE'] || 'headless'
  unless `VBoxManage -q list runningvms`.include?(VMNAME)
    sh "VBoxManage -q startvm #{VMNAME} --type #{type}"
  end
end

desc "stop the #{VMNAME} vm (poweroff)"
task :stop do
  if `VBoxManage -q list runningvms`.include?(VMNAME)
    sh "VBoxManage -q controlvm #{VMNAME} poweroff"
  end
end

desc "reset the vm to SNAPSHOT (default BASE)"
task :reset do
  type = ENV['TYPE'] || 'headless'
  name = ENV['SNAPSHOT'] || 'BASE'
  
  if `VBoxManage -q list runningvms`.include?(VMNAME)
    sh "VBoxManage -q controlvm #{VMNAME} poweroff"
  end
  
  sh "VBoxManage -q snapshot #{VMNAME} restore #{name.upcase}"
  sh "VBoxManage -q startvm #{VMNAME} --type #{type}"
end

desc "take the snapshop specified by SNAPSHOT"
task :snapshot do
  name = ENV['SNAPSHOT']
  raise "no snapshot name specified in ENV['SNAPSHOT']" unless name
  
  `VBoxManage -q snapshot #{VMNAME} delete #{name.upcase} > /dev/null`
  sh "VBoxManage -q snapshot #{VMNAME} take #{name.upcase}"
end

desc "print the state of the #{VMNAME} vm"
task :state do
  if `VBoxManage -q list runningvms`.include?(VMNAME)
    puts "running"
  else
    puts "stopped"
  end
end

desc "ssh to the #{VMNAME} vm (executes COMMAND)"
task :ssh do
  # To prevent ssh errors, protect the private key
  FileUtils.chmod(0600, KEYPATH)
  
  # Patterned after vagrant/ssh.rb (circa 0.6.6)
  platform = RUBY_PLATFORM.to_s.downcase
  ssh = "ssh -p 2222 -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o IdentitiesOnly=yes -i #{KEYPATH} #{VUSER}@localhost #{ENV['COMMAND']}"
  
  # Some hackery going on here. On Mac OS X Leopard (10.5), exec fails
  # (GH-51). As a workaround, we fork and wait. On all other platforms, we
  # simply exec.
  
  pid = nil
  pid = fork if platform.include?("darwin9") || platform.include?("darwin8")
  Kernel.exec(ssh)  if pid.nil?
  Process.wait(pid) if pid
end

#
# LineCook Helpers
#

helpers_dir = File.expand_path('../helpers', __FILE__)
require 'line_cook/helper'

LineCook::Helper.each_helper(helpers_dir) do |dir, helper|
  const_path = dir[(helpers_dir.length+1)..-1]
  next if const_path.nil? || const_path.empty?
  
  const_name = const_path.gsub(/\/(.?)/) { "::" + $1.upcase }.gsub(/(^|_)(.)/) { $2.upcase }
  target     = File.expand_path("../lib/#{const_path}.rb", __FILE__)
  
  if ENV['FORCE'] == 'true' && File.exists?(target)
    FileUtils.rm(target)
  end
  
  file target => helper.sources do
    content = helper.build(const_name)
    
    target_dir = File.dirname(target)
    unless File.exists?(target_dir)
      FileUtils.mkdir_p(target_dir) 
    end
    
    File.open(target, 'w') {|io| io << content }
  end

  namespace :helpers do
    desc "generate #{const_name}"
    task const_path => target
  end
  
  task :helpers => "helpers:#{const_path}"
end

desc "generate all helpers"
task :helpers

#
# LineCook Nodes
#

nodes_dir    = File.expand_path('../nodes', __FILE__)
recipe_dir   = File.expand_path("../recipes", __FILE__)
script_dir   = File.expand_path("../scripts", __FILE__)
package_dir  = File.expand_path("../packages", __FILE__)

require 'line_cook/node'
require 'line_cook/recipe'

LineCook::Node.each_node(nodes_dir) do |node_path, node|
  node_name = node_path[(nodes_dir.length+1)..-1].chomp('.js')
  
  script_paths = node.recipes.collect do |recipe_name|
    recipe_path = File.join(recipe_dir, "#{recipe_name}.rb")
    script_path = File.join(script_dir, node_name, recipe_name)
    
    file script_path => ['helpers', node_path, recipe_path] do
      FileUtils.rm_r(script_path) if File.exists?(script_path)
      FileUtils.mkdir_p(script_path)
      
      recipe = LineCook::Recipe.new(recipe_name, :attrs => node.attrs)
      recipe.evaluate(recipe_name)
      recipe.close
      recipe.registry.each_pair do |source, target|
        FileUtils.cp source, File.join(script_path, target)
      end
    end
    
    script_path
  end
  
  namespace :nodes do
    desc "generate #{node_name}"
    task node_name => script_paths
  end
  
  task :nodes => "nodes:#{node_name}"
end

desc "generate all nodes"
task :nodes